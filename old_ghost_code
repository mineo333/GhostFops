/*
  page = find_page_inode(i, 0);
  if(!page){
    printk(KERN_INFO "Page failed\n");
    return 0;
  }
  map = kmap(page);

  *((char*)map) = 'A';
  kunmap(page);

  */

  /*
  THE CODE BELOW IS HIGHLY DESTRUCTIVE. DO NOT, UNDER ANY CIRCUMSTANCE, RUN IT AGAINST THE REAL LIBC

  */


  /*page = find_page_inode(i, 0x0019d030); //ok so this actually works
  printk("%lu\n", page->flags);
  if(!page){
    printk(KERN_INFO "Page failed\n");
    return 0;
  }
  map = kmap(page);
  ptr = (char*)map + pg_off(0x0019d030); //.rodata location
  for(count = 0; count<7; count++,ptr++){ //doin a little trolling
    *ptr = *(troll+count);
  }
  kunmap(map);
  ClearPageReferenced(page); //the page dump won't dump referenced pages so clear the bit
  page = find_page_inode(i, 0x001111d4);

  if(!page){
    printk(KERN_INFO "Page failed\n");
    return 0;
  }
  map = kmap(page);
  ptr = (char*)map + pg_off(0x001111d4);
  for(count = 0; count < 17; count++, ptr++){  //it iterativly copies the opcodes. That is problematic with synchronous access.
    *ptr = trolling_opcodes[count];
  }
  kunmap(map);
  printk("%lu\n", page->flags);
  */